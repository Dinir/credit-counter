<!DOCTYPE html>
<html lang="en">

<!--
Customizable CSS

body {
  background-color: BACKGROUND_COLOR;
  color: TEXT_COLOR;
  font-family: FONT;
}
.beingUpdated {
  color: FLASH_COLOR_WHEN_NUMBER_CHANGES;
}
.isResetting {
  color: FLASH_COLOR_WHEN_ABOUT_TO_BE_RESET;
}
-->

<head>
  <meta charset="utf-8">
  <title>Just a Counter</title>
  <meta name="author" content="Dinir Nertan">
  
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="main.css">
</head>

<body>
  <div id="counter" class="notBeingUpdated">0</div>
  <div id="converter" class="notBeingUpdated">0</div>
  <div id="cover"></div>
</body>

<script src="grabGamepadInfo.js"></script>
<script src="getQueryMap.js"></script>
<script>
  const score = {
    data: 0
  }
  const conversion = {
    us: count => count < 4 ?
      (count * 25) + '¢' :
      '$' + (count / 4),
    jp: count => '¥' + (count * 100),
    ko: count => '₩' + (count * 500)
  }

  /*
   * expected query parameters:
   * convert=[us|jp|ko]
   * color=[css-appliable color for text]
   * button=[button index number]
   */
  const queryMap = getQueryMap()
  let conversionUnit = queryMap.get('convert') || null
  const buttonToTrack = queryMap.get('button') || 8
  const changeColor = queryMap.has('color')
    
  if (changeColor) {
    document.body.style.setProperty('color', queryMap.get('color'))
  }
  if (conversionUnit) {
    if (!conversion.hasOwnProperty(conversionUnit)) {
      conversionUnit = null
    } else {
      document.body.classList.add('two-line')
    }
  }

  const scoreDom = {
    counter: document.getElementById('counter'),
    converter: document.getElementById('converter'),
    cover: document.getElementById('cover'),
    classListUpdate: (method, ...classNames) => {
      [
        scoreDom.counter,
        scoreDom.converter
      ].forEach(v => {
        v.classList[method](...classNames)
      })
    },
    update: amount => {
      if (typeof amount !== 'number') { return }
      score.data += amount
      if (score.data < 0) { score.data = 0 }
      scoreDom.counter.innerHTML = score.data
      if (conversionUnit) {
        scoreDom.converter.innerHTML =
          conversion[conversionUnit](score.data)
      }

      scoreDom.classListUpdate('replace', 'notBeingUpdated', 'beingUpdated')
      setTimeout(
        () => scoreDom.classListUpdate('replace', 'beingUpdated', 'notBeingUpdated'), 
        16
      )
    },
    reset: () => {
      scoreDom.update(-1 * score.data)
      scoreDom.classListUpdate('remove', 'isResetting')
    }
  }

  const resetTimer = {
    timerID: null,
    interval: 500,
    timerOn: () => {
      if (!resetTimer.timerID) {
        resetTimer.timerID = setTimeout(scoreDom.reset, resetTimer.interval)
        scoreDom.classListUpdate('add', 'isResetting')
      }
    },
    timerOff: () => {
      if (resetTimer.timerID >= 0) {
        clearInterval(resetTimer.timerID)
        resetTimer.timerID = null
        scoreDom.classListUpdate('remove', 'isResetting')
      }
    }
  }

  const changeNumber = function (e) {
    const scrollingUp = e.deltaY < 0
    switch (scrollingUp) {
      case true:
        scoreDom.update(1)
        break
      case false:
        scoreDom.update(-1)
        break
    }
  }
  const isJustReleased = (() => {
    let beingPressed = false
    return beingUpdated => {
      switch (beingUpdated) {
        case true:
          if (!beingPressed) {
            beingPressed = true
          }
          break
        case false:
          if (beingPressed) {
            beingPressed = false
            return true // is just released
          }
          break
      }
      return false // is not just released
    }
  })()

  handler.update = () => {
    const buttonState = gamepads[0].buttons[buttonToTrack].pressed
    const updateNeeded = isJustReleased(buttonState)
    if (updateNeeded) {
      scoreDom.update(1)
    }
  }
  rAF(() => handler.refresh(gamepads))
  scoreDom.cover.addEventListener('wheel', changeNumber)
  scoreDom.cover.addEventListener('mousedown', resetTimer.timerOn)
  scoreDom.cover.addEventListener('mouseup', resetTimer.timerOff)
  scoreDom.cover.addEventListener('mouseleave', resetTimer.timerOff)
</script>

</html>
